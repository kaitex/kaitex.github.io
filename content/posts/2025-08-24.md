---
title: "Overview of JWT Authentication and authorization in ASP .NET CORE"
slug: "JWT-auth"
date: "2025-08-10"
---

This course assumes you're already familiar with basics of backend like CRUD operation.

so Let's start

Before starting the implementation of authentication and authorization. lets have a quick look at JWT. How JWT work and overview of JWT.
Suppose a user tyring to login in Facebook, User enter email and password in login Form and press login button. After pressing the login button , user sends the user's data (email and password) to the server's API Endpoints. When the Server validates the user Credentials and confirms that the user is valid. its going to send encoded JWT containing users claims and metadata. Then clients send a request with the JWT in the Authorization header for access. If the JWT is valid server returns the requested protected resources to the client (return to Facebook home page). Lets see this in big picture:

![Alt text](/jwt/jwt.png)

## What is JWT!

JSON Web Token (JWT) is an open standard [(RFC 7519)](https://datatracker.ietf.org/doc/html/rfc7519) .JWT enable a secure way to transmit data between two parties in the form of JSON Object . JWT consist of three parts separated by dots. It contains:

1.  Header
2.  Payload
3.  Signature
    Typically JWT looks like

    `XXXXX.YYYY.ZZZZ`

lets break down the different parts.

### Header:

The first part of JWT is Header. It is a string encoded in Base64 and contains the token type and algorithm such as HMAC SHA256 or RSA. .

```JSON
{
   "alg":HS256,
   "typ":"JWT",
}
```

### Payload:

It is a JavaScript object encoded in the base 64 format or a string generated by Base64(OurData). Where OurData is the data that we want embedded into the token (aka claims).
There are three types of claims:

1. Registered claims
   These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Example are shown in above figures.

2. Private claims:
   These are the custom claims created to share information between parties that agree on using them and are neither _registered_ or _public_ claims.

3. Public Claims:
   There are the claims that we can define and use for our own data.

### Signature

It is a string generated by hashing the header , payload with a secret i.e. HMACSHA256(header + '.'+ payload,secret)

The signature is used to verify the message wasn't changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.

So if malicious users try to modify the values in the payload they have to recreate the signature. To modifies they need the secret key that only the server knows about. On the server side we can easily verify the values are original or not by comparing the original signature with new signature.

After putting all together we get the real JWT token. One example of JWT :

```nginx
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InBZWXp6UHMwOHd2SnRySjlqUU01diJ9.eyJpc3MiOiJodHRwczovL2Rldi1vcGIya3FyeTZ2MHVwanFoLnVzLmF1dGgwLmNvbS8iLCJzdWIiOiJCWEJZTmFtZEM5RTJMWkdJaWVsVzQwcEphOHFWWWRodkBjbGllbnRzIiwiYXVkIjoiaHR0cHM6Ly9yZXN0dXJhbnQuY29tLyIsImlhdCI6MTc1NjM2NDAwMiwiZXhwIjoxNzU2NDUwNDAyLCJndHkiOiJjbGllbnQtY3JlZGVudGlhbHMiLCJhenAiOiJCWEJZTmFtZEM5RTJMWkdJaWVsVzQwcEphOHFWWWRodiJ9.0Oe-DfGtuLO0QVT7nV1KrVY3_ol6WFA5o8x0hGCFKOgPW9CtPaDSKvQi2klOE3RC5zK1puohm3wtwzZJRF_ahApn-5N9bKXKLcaomwyEBwg2tW7W1hpG4w9nFM1d0H_Qgbn9kWdxhp7ogEtiwxNZSjZqW_Gfo6QPT7uRgQVYY7wIJU8TJRiqkwNSZPBzowz7gn7h_KuXNoCdmCcB4k7kpDWLNGK0lSj8RzkYHipNhiKq5ArCew9L9EFYxpfydiWaW_2lRCzmsY0nufiTO928Y8sS7jDoQGDzq4DLvMOG0rJxn3_13Xym8mvF6GsmvwYpgpIo4Tbv2bAnz54Z4DZwKg
```

![Alt text](/jwt/explain.png)

## Creating ASP.NET Core Web API Project

Now lets create a new project. You can create a project on either dotnet core CLI or use visual studio. we will use visual studio, you can choose any other tools too, I will give the command to create and packages too if you are using any other tools like visual studio code or rider etc. For database I will be using PostgreSQL but if you have SQL you can follow along too.

```bash
dotnet new webapi -n AuthApi
```

This command will create a dotnet web api project.

```bash
cd dotnet
```

Now you are inside the project folder now install some packages that are required for this project.

```bash
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.Design

```

So these are the packages that will be required for this project. if you are using SQL replace `dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL` with:

```bash
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
```

If you are using .NET 9, you need to install the following package:

```bash
dotnet add package Scalar.AspNetCore
```

In .NET 8, [Swagger](https://swagger.io/) comes preconfigured in new projects. However, in .NET 9, this feature is not included by default, so you must install it manually to use it.

For now, we’ll be using [Scalar](https://scalar.com/?utm_source=chatgpt.com#api-docs). If you prefer to set up Swagger instead, follow the official guide [here](https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-8.0&tabs=visual-studio&utm_source=chatgpt.com).

If you’re not familiar with Swagger or Scalar: it’s a tool for describing and documenting APIs.

## Configure JWT Authentication

To configure JWT Authentication in .Net Core, we need to modify `Program.cs` file or `Startup.cs` if you are using .Net core 5
Now lets add the code to configure JWT right above `builder.Services.AddControllers(); `line

```CS
builder.Services.AddAuthentication(opt=>
{
    opt.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    opt.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Token"]!))
        };
    });
```

In order for this to work, we have to add a few using directives.

```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using Scalar.AspNetCore;
```

and we need to add few configuration in `AppSetting.json` file. Add these line of code :

```JSON
"jwt": {
  "Token":"MySuperSecureAndRandomKeyThatLooksJustAwesomeAndNeedsToBeVeryVeryLong!!!11loneeleven",
 "Issuer": "MyAwesomeApp",
 "Audience": "MyAwesomeAudience"
}
```

First, we add the JWT authentication middleware by calling the `AddAuthentication` method. We then specify the default authentication scheme using `JwtBearerDefaults.AuthenticationScheme` as well as the `DefaultChallengeScheme`.

By calling `AddJwtBearer`, we enable JWT authentication with the default scheme and provide parameters to configure the JWT bearer options:

- The issuer is the actual server that created the token `validateIssuer = true`
- The receiver of the token is a valid recipient `validateAudience = true`
- The token has not expired `ValidateLifetime = true`
- The signing key is valid and is trusted by the server`(ValidateIssuerSigningKey=true)`

we are providing the values for issuer, audience and the secret key that the server uses to generate the signature for JWT.
There is one more step we need to do to make our authentication middleware available to the application.

```Cs
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    app.MapScalarApiReference();

}
app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();
```

Notice that `app.MapScalarApiReference()` must be called inside the development environment block (or wherever you want to expose the API documentation) so that the Scalar API reference UI is available when running the app.

So that all we need to configure in `program.cs ` for JWT Authentication.

### Securing API Endpoints

To maintain simplicity ,lets create a new API endpoints by creating new file called `FooController.cs`.Inside your project you have `WeatherForcast.cs` and `WeatherForcastController.cs` file, you can also use that code for applying secure endpoint. But for now we are going to use new `api/foo` endpoint to display a list of student.
This endpoint is going to be secure and only logged user can access this endpoint.
So We have to create a an empty `fooController` in the controller folder. Inside the Controller, we are going to add a `Get` method that is going to return message called `Hello foo`.We are going to secure this endpoint by applying the `[Authorize]` attribute above the function.

```Cs
    [ApiController]
    [Route("api/[controller]")]
    public class FooController : ControllerBase
    {
        [HttpGet]
        [Authorize]

        public IActionResult Foo()
        {
            return Ok(new { message = $"Hello foo" });
        }
    }
```

To be able to use the Authorized attribute we have to include using directive inside the file:

```cs
using Microsoft.AspNetCore.Authorization`
```

`Authorized` attribute on top of the `GET` method restricts access to only authorized user. only user who logged in can fetch the message. if we make the request to `'https://localhost:7011/api/Foo` without `bearer token` we will get error of 401 (unauthorized). Here the error while fetching the data with authorization token.

![Alt text](/jwt/error.png)

### Creating the login Endpoints

To access a protected route, we first need a login endpoint. A user will submit a username and password, and if the credentials are valid, we will issue a JSON Web Token (JWT) for the client to use in subsequent requests.

Before implementing the authentication controller, we need to create a User model to store the User ID, email, and password, along with a User DTO for registering new users.

let's create a `User.cs` Model with properties of id, email and password and `UserDto.cs` for transferring data that receives from client to User Model.

```CS
// User.cs
 public class User
 {
     public int Id { get; set; }
     public String Email { get; set; } = String.Empty;
     public String Pass { get; set; } = String.Empty;
 }
  //UserDto.cs
    public class UserDto
    {

        public String Email { get; set; } = String.Empty;
        public String Pass { get; set; } = String.Empty;
    }

```

## Creating a Database Connection for Storing User Data

Now let's create a connection with database for storing the data of user.
First, create a folder named `Data` in your project. Inside that folder, create a file called `UserDbContext.cs` and add the following code:

```Cs
using AuthDemo.Models;
using Microsoft.EntityFrameworkCore;

namespace AuthDemo.Data
{
    public class UserDbContext : DbContext
    {
        public UserDbContext(DbContextOptions options) : base(options)
        {
        }

      public DbSet<User> users { get; set; }
    }
}

```

In above `UserDbContex` inherits from [DbContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext?view=efcore-9.0), which is the primary class in Entity Framework for interacting with a database. It represent the session with the database, allowing you to query and save data easily without raw query. `UserDbContext `constructor allows you to configure your `DbContext` from outside the class using dependency Injection. `DbContextOptions options` contains configuration like connection string, database provider, or other EF Core options
`: base(options)` passes these options to the base `DbContext` class. `DbSet<User>`Represents the `Users` table in your database. Using this property, you can query, add, update, and delete users using EF Core’s intuitive API.

```Cs
builder.Services.AddDbContext<UserDbContext>(op => op.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));
```

`AddDbContext<UserDbContext>(...)` registers your `DbContext` with the dependency injection system, so you can use it anywhere in your application. `UseNpgsql(...)` tells EF Core to use PostgreSQL as the database provider. `GetConnectionString("DefaultConnection")` reads the connection string from `appsettings.json`. With this setup, your application can work with the `Users` table through `UserDbContext` without writing raw SQL, as EF Core handles all the queries for you.

```JSON
"ConnectionStrings": { "DefaultConnection": "Host=localhost;Port=5432;Database=fooddb;Username=user;Password=pass123" },
```

Now lets create a `AuthController.cs` inside the `Controller` folder
Inside the `AuthController` we are going to add `Register` and `Login` action to validate the user's credentials . If the credentials are valid , we are going to issue JWT. Now first let write a logic for registering form.

```Cs
namespace AuthDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UserController : ControllerBase
    {
        private readonly UserDbContext _db;
        private readonly IConfiguration _config;
        public UserController(UserDbContext db, IConfiguration config)
        {
            this._db = db;
            this._config = config;
        }


        [HttpGet]
        public async Task<ActionResult<IEnumerable<User>>> GetAllUser()
        {
            var user = await _db.users.ToListAsync();

            return Ok(user);
        }
```

In the above code, we first define Dependency Injection inside the `UserController` constructor. `UserDbContext _db` This is a database context class provided by Entity Framework Core. It allows us to interact with the database (in this case, the `Users` table). `IConfiguration _config` This is used to access configuration settings from `appsettings.json` or environment variables (e.g., connection strings, JWT secret keys, etc.). Both of these are injected automatically by ASP.NET Core’s built-in Dependency Injection (DI) container when the controller is created.
Then We define `GetAllUser` endpoint that fetches all user records from database table `users`. - `async` makes the method asynchronous, similar to how `async/await` works in JavaScript. `Task` represents an operation that runs in the background and eventually returns a result. `ActionResult<IEnumerable<User>>` means the method will return either a successful response with a list of users or an appropriate HTTP error code.

So Now lets implement logic for `Register` Endpoint:

```CS
[HttpPost("Register")]
public async Task<ActionResult<User>> Register(UserDto regUser)
{
    if (regUser == null) return BadRequest(400);
    var emailCheck = _db.users.Any(u => u.Email == regUser.Email);
    if (emailCheck) return BadRequest("User already Exist");
    var newUser = new User { };
    var hashedPass = new PasswordHasher<User>().HashPassword(newUser, regUser.Password);

    newUser.Email = regUser.Email;
    newUser.Password = hashedPass;

 _db.Add(newUser);
    await _db.SaveChangesAsync();
    return Ok(newUser);

}
```

We decorate the `Register` action with the `[HttpPost("Register")]` attribute. This makes the endpoint available at:
`POST /api/User/Register`

Inside the Register method, If the request body is `null`, we return `400 Bad Request`. we will be verifying weather if user already exist or not by comparing email given by user with email inside the database. If already exit then it will send a `BadRequest`. We instantiate `User` and then hash the password using `PasswordHasher<User>`. Then we set `Email` and `Password` fields for the new user object. Add the new user to the context and call `SaveChangesAsync()` to persist it and if anything success then it will send Return success.

```Cs
  [HttpPost("login")]
  public async Task<ActionResult<User>> Login(UserDto log)
  {
      if (log == null) return BadRequest("null");
      var validUser = await _db.users.FirstOrDefaultAsync(u => u.Email == log.Email);
      if (validUser is null) return BadRequest("Something is Wrong");
      var result = new PasswordHasher<User>().VerifyHashedPassword(validUser, validUser.Password, log.Password);
      if (result == PasswordVerificationResult.Failed)
          return Unauthorized();

      var token = GenerateToken(validUser);
      return Ok(new { token });
  }
```

We start by decorating our `Login` endpoint with the `[HttpPost("Login")]` attribute. This maps the action to the route:

`POST /api/User/Login`

Inside the `Login` method, the first step is to check if the incoming request body is `null`. If it is, we return a `BadRequest` response.

Next, we attempt to find a user in the database matching the provided email. If no user is found, we again return a `BadRequest`, indicating that the credentials are invalid.

If the user exists, we use the `PasswordHasher<>` class to verify that the provided password matches the stored hashed password. If the verification fails, we return `Unauthorized`.

Finally, if the credentials are valid, we generate a JWT token for the user and return it in the response. This token can then be used to authenticate subsequent requests.

```CS
private string GenerateToken(User user)
{
    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, user.Email),
        new Claim("userId", user.Id.ToString()),
        new Claim(ClaimTypes.Name, user.Email),
        new Claim(ClaimTypes.Role, "User")
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Token"]!));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: _config["Jwt:Issuer"],
        audience: _config["Jwt:Audience"],
        claims: claims,
        expires: DateTime.UtcNow.AddHours(1),
        signingCredentials: creds
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}
```

The `GenerateToken` method is used to create a JWT token for an authenticated user. First, we define a set of `claims` that describe the user, such as their email, user ID, and role. These claims are included in the token and can be used to identify the user in future requests.

Next, we generate a security key from a secret stored in the configuration and use it to create signing credentials with the `HmacSha256` algorithm. This ensures the token is securely signed and cannot be tampered with.

We then create the `JwtSecurityToken`, specifying the issuer, audience, claims, expiration time (1 hour), and signing credentials. Finally, we return the serialized token as a string using `JwtSecurityTokenHandler().WriteToken(token)`.

The generated token is then sent to the client after a successful login and can be used to authenticate future API requests.

Here’s a polished rewrite of your “Testing the JWT Authentication” section in the same tutorial style as your previous explanations:

### Testing the JWT Authentication

Now that our endpoints are ready, let's test the authentication flow. We will use Postman (or any API testing tool like Scalar) to send requests.

#### 1. Register a User

Send a POST request to:

```
https://localhost:7099/api/User/Register
```

with the following JSON body:

```json
{
  "email": "jhon@doe.com",
  "password": "Jhon"
}
```

After sending the request, you should see a response confirming that the user has been successfully created:

![Alt text](/jwt/register.png)

#### 2. Login to Get JWT

Next, use the login endpoint to obtain a JWT token. Send a POST request to:

```
https://localhost:7099/api/User/Login
```

with the same credentials used during registration. If the login is successful, the response will include the JWT token:

![Alt text](/jwt/login.png)

Now that we have a JWT token from the login endpoint, let's verify if we can access a protected endpoint.

In your API testing tool, send a request to a secure endpoint (for example, `GET /api/User/SecureData`) and include the JWT token in the Authorization header:

```JSON
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJqaG9uQGRvZS5jb20iLCJ1c2VySWQiOiI1IiwiaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvd3MvMjAwNS8wNS9pZGVudGl0eS9jbGFpbXMvbmFtZSI6Impob25AZG9lLmNvbSIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvcm9sZSI6IlVzZXIiLCJleHAiOjE3NTY0NDEyNTEsImlzcyI6Ik15QXdlc29tZUFwcCIsImF1ZCI6Ik15QXdlc29tZUF1ZGllbmNlIn0.rhH9nX2dReDQHrTeGQKLGDM_MhVO93xJuX_fX00FaGM
```

If the token is valid, the server will allow access and return the requested data:
![Alt text](/jwt/secure.png)

If you omit the token or provide an invalid token, the request will be unauthorized and the server will respond with `401 Unauthorized`.

This confirms that our JWT authentication setup is working correctly only authenticated users with a valid token can access protected endpoints.

## Recap

So, we've basically taken a look at implementation of JWT based Authentication in ASP.NET Core. We have covered Registering a new user , logging in and validating credentials , Generating a JWT token using Generate Token and Accessing a secure endpoint using token You can further extend this by adding roles, token expiration handling, and refresh tokens for a complete authentication flow. I will be posting a follow up diving more into Backend topics.

## References

[ASP.NET Core Authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-9.0&utm_source=chatgpt.com) [JWT Bearer Authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/configure-jwt-bearer-authentication?view=aspnetcore-9.0&utm_source=chatgpt.com).
[Code Maze](https://code-maze.com/authentication-aspnetcore-jwt-1/)
